## 上下文切换代码调试

。。。


##  什么是操作系统
#### 虚拟化：操作系统同时保存多个状态机
C程序 = 状态机
* 初始状态： main(argc, argv)
* 状态迁移： 指令的执行，包括syscall

实际上，在 UNIX/Linux 系统内核完成初始化后，只有一个 init 进程被启动，从此以后，操作系统内核就化身为了一个事件驱动的程序、状态机的管理者，仅在中断和系统调用发生时开始执行。

下面看一段小代码
```c
for(int i = 0; i < 2; i++){
	fork();
	printf("Hello \n");
}
```
> 写出代码的运行结果。
*  ./a.out
*  ./a.out | cat

1. 当执行./a.out时，会打印 6 个 Hello
2. 当执行./a.out | wc -l 时，会打印 8 个 Hello ? 这是为什么呢？

不妨用 strace 来看一下。
我们发现，

> 我们的 printf 不总是打印到标准输出的。也就是说它根据标准输出连接的是终端还是管道，它会做不同的行为，这里连接到了管道，也就把输出放到一个缓冲区里面 。当第一个循环之后，缓冲区里面有一个 hello，有两个进程；第二次循环完毕后，缓冲区里面有 2 个 hello, 总共 4 个进程。所以打印 8 个。 



### 环境变量
应用程序执行的环境。

* export: 告诉shell在创建子进程的时候设置环境变量。












