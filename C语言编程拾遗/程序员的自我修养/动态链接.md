## 动态链接小例子
```c
/* Program1.c */
#include "Lib.h"

int main()
{   
    foobar(1);
    return 0;
}

/* Program2.c */
#include "Lib.h"

int main()
{   
    foobar(2);
    return 0;
}

/* Lib.c */
#include <stdio.h>

void foobar(int i) 
{
    printf("Printing from Lib.so %d\n", i);
}

/* Lib.h */
#ifndef LIB_H
#define LIB_H

void foobar(int i);

#endif
```
编译命令:
```
gcc -fPIC -shared -o Lib.so Lib.c
gcc -o Program1 Program1.c ./Lib.so
gcc -o Program2 Program2.c ./Lib.so
```
`Lib.so`为什么要参与链接过程呢？
`Program1.c`被编译成`Program1.o`时，编译器还不知道`foobar()`的地址，当链接器将`Program1.o`链接成可执行文件时，必须确定`Program1.o`中所引用的`foobar()`函数的性质。如果`foobar()`是一个定义于其他静态目标模块中的函数，那么链接器将会按照静态链接的规则，将`Program1.o`中的`foobar`地址引用重定位；如果`foobar()`是一个定义在某个动态共享对象中的函数，那么链接器就会将这个符号的引用标记为一个动态链接的符号，不对它进行地址重定位，把这个过程留到装载时再进行。
`Lib.so`中保存了完整的符号信息（因为运行时进行动态链接还须使用符号信息），把`Lib.so`也作为链接的输入文件之一，链接器在解析符号时就可以知道：`foobar`是一个定义在`Lib.so`的动态符号。这样链接器就可以对`foobar`的引用做特殊的处理，使它成为一个对动态符号的引用。

`ld-2.6.so`是Linux下的动态链接器，它与普通共享对象一样被映射到了进程的地址空间，在系统开始运行`Program1`之前，首先会把控制权交给动态链接器，由它完成所有的动态链接工作以后再把控制权交给`Program1`，然后开始执行。



## 地址无关代码
要让程序模块中共享的指令部分在装载时不需要因为装载地址的改变而改变，所以实现的基本想法就是把指令中那些需要被修改的部分分离出来，跟数据部分放在一起，这样指令部分就可以保持不变，而数据部分可以在每个进程中拥有一个副本。这种方案就是目前被称为地址无关代码（PIC, Position-independent Code）的技术。
共享对象模块中的地址引用按照是否为跨模块分成两类：模块内部引用和模块外部引用；按照不同的引用方式分为指令引用和数据访问，得到4种情况：
1. 模块内部的函数调用、跳转等。
2. 模块内部的数据访问，比如模块中定义的全局变量、静态变量。
3. 模块外部的函数调用、跳转等。
4. 模块外部的数据访问，比如其他模块中定义的全局变量。

```c
static int a;
extern int b;
estern void ext();

void bar() {
    a = 1;   // type2:模块内部的数据访问 
    b = 2;   // type4:跨模块的数据访问
}

void foo() {
    bar();   // type1:模块内部的函数调用
    ext();   // type3:模块间的函数调用
}
```
**编译器不能确定`b`和`ext()`在模块外部还是模块内部的其他目标文件，所以只能当模块外部来处理**。

### 1.模块内部函数调用
采用相对地址调用/跳转，不需要重定位。关于共享对象全局符号介入（Global Symbol Interposition）问题，在“动态链接的实现”中详细介绍。


### 2.模块内部数据访问
模块内部数据的访问，采用相对于当前指令加上固定的偏移量来实现。现代的体系结构中，数据的相对寻址往往没有相对于当前指令地址（PC）的寻址方式，所以ELF用了一个很巧妙的办法来得到当前的PC值。E
这是上面的`bar()`函数中`a = 1`的汇编代码:
```
 44f: e8 40 00 00 00        call   494 <__i686.get_pc_thunk.cx>
 454: 81 c1 8c 11 00 00     add    $0x118c,%ecx
 45a: c7 81 28 00 00 00 01  movl   $0x1,0x28(%ecx)         // a = 1

 00000494 <__i686.get_pc_thunk.cx>:
 494: 8b 0c 24              mov    (%esp),%ecx
 497: c3                    ret 
```
我们看到`__i686.get_pc_thunk.cx`函数的作用就是把返回地址放入到寄存器`ecx`中，也就是下一条指令的地址(`esp`寄存区指向栈顶，而处理器在执行call指令后，下一条指令的地址会被压到栈顶)。
接着是add和mov指令，变量a的地址是add指令地址（保存在ecx寄存器）加上两个偏移量0x118c和0x28，即如果模块被装载到0x10000000地址，那么变量a的地址是0x10000000 + 0x454 + 0x118c + 0x28 = 0x10001608。


### 3.模块间的数据访问
ELF会在数据段里面建立一个指向这些变量的指针数组，称为**全局偏移表**（Global Offset Table，GOT）

当指令中需要访问变量b时，程序会先找到GOT，然后根据GOT中变量所对应的项找到变量的目标地址。每个变量都对应一个4个字节的地址，链接器在装载模块的时候会查找每个变量所在的地址，然后填充GOT中的各个项，以确保每个指针所指向的地址正确。由于GOT本身是放在数据段的，所以它可以在模块装载时被修改，并且每个进程都可以有独立的副本，相互不受影响。

GOT如何做到指令的地址无关性？从第2种类型的数据访问可知，模块在编译时可以确定模块内部变量相对于当前指令的偏移，那么也可以在编译时确定GOT相对于当前指令的偏移。


### 4.模块间的函数调用
GOT中相应的项保存的是目标函数的地址，当模块需要调用目标函数时，可以通过GOT中的项进行间接跳转。
调用`ext()`函数的方法与上面访问变量b的方法基本类似，先得到当前指令地址PC，然后加上一个偏移得到函数地址在GOT中的偏移，然后一个间接调用：
```
call   494 <__i686.get_pc_thunk.cx>
add    $0x118c,%ecx
mov    0xfffffffc(%ecx),%eax
call   *(%eax)
```
后面将介绍延迟绑定的内容，这是一种优化。


### 共享模块的全局变量问题
上面的情况中没有包含定义在模块内部的全局变量的情况。
一种特殊情况：当一个模块引用了一个定义在共享对象的全局变量的时候，比如一个共享对象定义了一个全局变量`global`，而模块module.c中是这么引用的：
```c
extern int global;
int foo()
{
   global = 1;
}
```
上面说过，编译器无法判断`global`是否为跨模块的调用。
如果上面的module.c是程序可执行文件的一部分(就比如说含有`main`函数的文件)，由于程序主模块的代码并不是地址无关代码，即不使用PIC机制，它引用这个全局变量的方式跟普通数据访问方式一样，编译器会产生这样的代码：
```
movl $0x1,XXXXXXXX
```
XXXXXXXX就是global的地址。由于可执行文件在运行时并不进行代码重定位，所以变量的地址必须在链接过程中确定下来。为了能够使得链接过程正常进行，链接器会在创建可执行文件时，在它的“.bss”段创建一个`global`变量的副本。导致同一个变量同时存在于多个位置中的问题。如何解决？
于是解决的办法只有一个，那就是**所有的使用这个变量的指令都指向位于可执行文件中的那个副本**。ELF共享库在编译时，默认都把定义在模块内部的全局变量当作定义在其他模块的全局变量，也就是说当作前面的类型四，通过GOT来实现变量的访问。当共享模块被装载时，如果某个全局变量在可执行文件中拥有副本，那么动态链接器就会把GOT中的相应地址指向该副本，这样该变量在运行时实际上最终就只有一个实例。



## 延迟绑定
程序运行过程中，会有很多函数没有用到（错误处理函数，没有使用的功能模块等），所以没有必要一开始就把所有函数都链接好，ELF采用延迟绑定的方法，基本思想是当函数第一次被用到时才由动态链接器进行绑定（符号查找，重定位等），没用到的不绑定。这提高了程序的启动速度。
当调用某个外部模块的函数时，并不直接通过GOT跳转，而是通过一个叫作PLT项的结构来进行跳转，每个外部函数在PLT中都有一个相应的项，比如`bar()`函数在PLT中的项的地址称为`bar@plt`。来看看`bar@plt`的实现：
```
bar@plt:
jmp *(bar@GOT)
push n
push moduleID
jump _dl_runtime_resolve
```
`bar@plt`的第一条指令是通过GOT间接跳转的指令。`bar@GOT`表示GOT中保存`bar()`这个函数相应的项。
如果链接器在初始化阶段已将`bar()`的地址填入该项，就跳转到`bar()`。但为了实现延迟绑定，链接器在初始化阶段并没有将`bar()`的地址填入到该项，而是将上面代码中第二条指令`push n`的地址填入到`bar@GOT`中，这个步骤不需要查找任何符号，所以代价很低。很明显，第一条指令的效果是跳转到第二条指令，相当于没有进行任何操作。
第二条指令将一个数字n压入堆栈中，这个数字是bar这个符号引用在重定位表.rel.plt中的下标。接着又是一条push指令将模块的ID压入到堆栈，然后跳转到_dl_runtime_resolve。这实际上就是在实现`_dl_runtime_resolve`函数调用，它在进行一系列符号解析和重定位工作以后将bar()的真正地址填入到`bar@GOT`中。
之后当我们再次调用`bar@plt`时，第一条jmp指令就能够跳转到真正的`bar()`函数中，`bar()`函数返回的时候会根据堆栈里面保存的EIP直接返回到调用者，而不会再继续执行`bar@plt`中第二条指令开始的那段代码，那段代码只会在符号未被解析时执行一次。

